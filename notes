Todo
---- 
[ ] implement a sensor which only plots DEV B gyr_z ! 


Improvements for version 0.2 
---------------------------- 


[nov 5 2018] [ DONE ] 
Can implement a  TRANSFORMER node -- which simply fowards data but applies some function F to the data 
It can be plugged in between to other notes oto make a sort of declarative data pipe line (inspired by using the web audio 
interface and trying to pipe it to the state machine)

[ ] incorporate menuX into wrtsm 
[ ] within wrtsm menuX extension, show visualaziton of current node chain (based on pipe manager) 

[ ] create a event_detector node which uses RMS of last N packets and detects deviations for norm using threshold. 
- automatically gets RMS of nested vectors or sets , or keeps dictionary structure of object and gets RMS of fields 
- the ED node maintains its internal state buffer 
- it can do two things: 
-- 1) EMIT events (via: pm.connect(ed.events , event_processor)) 
-- 2) forward raw (via: pm.connect(ed.forward, grapher_node)) 

- can configure ED to IGNORE changes in specified paths of the data object , in order to do this the specified path is overwritten as 0 in each appended data packet 
- will first establish a baseline before attempting to extract events

[ ] CREATE OBJECT ORIENTED -> CLASS FOR A WRTSM *node* so that I can update all functionalities SIMULTANEOUSLY! 
- each node can either forward or not forward -> 
- you can set up a chain of nodes and then call .get_single_packet  on the last node and it will 
-- propagate back  
- etc... 
- each node has own pipe manager (so can call connect from itself) 
- each node has multiple output ports? 





Improvements for version 0.3
---------------------------- 
think broadly -- > 






Troubleshooting 
--------------- 

Date: Sat Oct 13 09:44:08 PDT 2018
Issue: Graph of the gyr_z was squiggly / noisy 
Suggested solution: Software is graphing data from both dev A and B and so x series is not monotonic. Filter out single device to graph 


Had an extra space AFTER the sensor name in the gui config object and that MADE THE GRAPH DO NOTHING (no updates) 



Common Mistakes
---------------
You can only visualize a sensor which has been ADDED to the state machine. If you are trying to visualize a sensor and the graph is not updating properly, turn on u_debug(true) and look at the series_buffer. If the data is not available for that series it means the sensor has not been added to the state machine [Sat Oct 13 10:07:07 PDT 2018] 




Things to be aware of
---------------------
[ ] It is cool that the css can be directly imported into the JS bundle, but must be careful since the css affects global document objects !  -- future versions should alleviate this error source 

[ ] Must be careful about assigning sensor levels ! The order that sensors are evaluated in makes a big difference ! 




For consideration later ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[Sat Oct 13 10:07:35 PDT 2018] 
Create a base class which has data_handler, process_data, stream_sample, etc... 
And the most stripped down , common properties 

Then the data_storage and web_socket and .. classes can inherit from that 

Then I can add functionality to the base class and and all the objects will inherit this functionality. This is efficient and more elegant than adding similar functionality to each class independently, especially when that functionality involves manipulation of data structures each class has . 


For Docs ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Last Skipped 
------------

A key aspect of modularity is to allow sensors to derive their values from other sensors. 
Another aspect is to allow for filtering of data streams. This means that some sensors may 
have new data each iteration, while others may choose to ignore that data packet. 
If a sensor chooses to ignore a data packet but there is another sensor which relies on it, then the other sensor should be able to also ignore that data packet. This is implemented using -- this.sensors[d]["last_skipped"] , as well as the get_sensor_last** fxns in the state_machine core module. 



